<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic AI Paper Search</title>
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }

        body.dark-theme {
            background: linear-gradient(135deg, #2c3e50 0%, #1a2533 100%);
            color: #f0f0f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: background-color 0.3s;
        }
        body.dark-theme .container {
            background: rgba(45, 55, 71, 0.95);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }


        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        body.dark-theme .header {
             background: linear-gradient(135deg, #1e2b38, #2980b9);
        }


        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            font-weight: 300;
            background: linear-gradient(45deg, #fff, #e3f2fd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .author-credit {
            position: absolute;
            bottom: 15px;
            right: 30px;
            opacity: 0.8;
            font-size: 0.9em;
            font-style: italic;
        }

        .main-content {
            padding: 30px;
        }

        .config-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        body.dark-theme .config-section {
            background: linear-gradient(135deg, #3a4759, #2c3645);
            border-color: #4a596d;
        }


        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }
        body.dark-theme label {
            color: #c0c0c0;
        }

        select, input, textarea {
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
            color: #333;
        }
        body.dark-theme select, body.dark-theme input, body.dark-theme textarea {
            background: #2c3645;
            border-color: #4a596d;
            color: #f0f0f0;
        }


        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        body.dark-theme select:focus, body.dark-theme input:focus, body.dark-theme textarea:focus {
            border-color: #5dade2;
            box-shadow: 0 0 0 3px rgba(93, 173, 226, 0.2);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        body.dark-theme .slider {
            background-color: #555;
        }


        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background-color: #3498db;
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        .database-selector {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .database-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        body.dark-theme .database-option {
            background: #2c3645;
            border-color: #4a596d;
        }

        .database-option:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }
        body.dark-theme .database-option:hover {
            border-color: #5dade2;
            background: #3a4759;
        }

        .database-option input[type="checkbox"] {
            margin: 0;
            width: auto;
            height: auto;
        }

        .database-option.selected {
            border-color: #3498db;
            background: #e3f2fd;
        }
        body.dark-theme .database-option.selected {
            border-color: #5dade2;
            background: #4a596d;
        }

        .search-section {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        body.dark-theme .search-section {
            background: linear-gradient(135deg, #3a4759, #2c3645);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .file-upload {
            border: 2px dashed #3498db;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: linear-gradient(45deg, #ffffff, #f8f9ff);
        }
        body.dark-theme .file-upload {
            border-color: #5dade2;
            background: linear-gradient(45deg, #3a4759, #2c3645);
        }

        .file-upload:hover {
            background: linear-gradient(45deg, #f8f9ff, #e3f2fd);
            border-color: #2980b9;
            transform: translateY(-2px);
        }
        body.dark-theme .file-upload:hover {
            background: linear-gradient(45deg, #4a596d, #3a4759);
            border-color: #76c7f0;
        }

        .file-upload.dragover {
            background: #e3f2fd;
            border-color: #1976d2;
            transform: scale(1.02);
        }
        body.dark-theme .file-upload.dragover {
            background: #4a596d;
            border-color: #52a8e8;
        }

        .uploaded-files {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px; /* Added margin */
        }

        .file-tag {
            background: #3498db;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-tag .remove {
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .search-input-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 18px 60px 18px 18px;
            font-size: 16px;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            transition: all 0.3s ease;
        }
        body.dark-theme .search-input {
            background: #2c3645;
            border-color: #4a596d;
            color: #f0f0f0;
        }

        .search-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        body.dark-theme .search-input:focus {
            border-color: #5dade2;
        }

        .search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .search-btn:hover {
            transform: translateY(-50%) scale(1.05);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #aaa; /* Darker disabled state for dark theme */
        }
        body.dark-theme .search-btn:disabled {
            background: #555;
        }


        .advanced-filters {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }
        body.dark-theme .advanced-filters {
            background: #3a4759;
            border-color: #4a596d;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .results-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        body.dark-theme .results-section {
            background: #2c3645;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sort-btn {
            padding: 8px 16px;
            border: 1px solid #e9ecef;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            color: #333;
        }
        body.dark-theme .sort-btn {
            background: #3a4759;
            border-color: #4a596d;
            color: #f0f0f0;
        }

        .sort-btn:hover, .sort-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        body.dark-theme .sort-btn:hover, body.dark-theme .sort-btn.active {
            background: #5dade2;
            border-color: #5dade2;
        }


        .paper-card {
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            background: white;
            position: relative;
            overflow: hidden;
        }
        body.dark-theme .paper-card {
            background: #3a4759;
            border-color: #4a596d;
        }

        .paper-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(135deg, #3498db, #2980b9);
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        .paper-card:hover {
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
        }
        body.dark-theme .paper-card:hover {
             box-shadow: 0 12px 30px rgba(0,0,0,0.3);
        }

        .paper-card:hover::before {
            transform: scaleY(1);
        }

        .paper-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .paper-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            line-height: 1.4;
            flex: 1;
        }
        body.dark-theme .paper-title {
            color: #e0e0e0;
        }

        .paper-title a {
            color: inherit;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .paper-title a:hover {
            color: #3498db;
        }
        body.dark-theme .paper-title a:hover {
            color: #5dade2;
        }

        .paper-source {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 10px; /* Added margin */
        }

        .paper-authors {
            color: #7f8c8d;
            margin-bottom: 12px;
            font-size: 0.95em;
            font-weight: 500;
        }
        body.dark-theme .paper-authors {
            color: #a0a0a0;
        }

        .paper-abstract {
            color: #555;
            line-height: 1.7;
            margin-bottom: 15px;
            font-size: 0.95em;
            max-height: 100px; /* Initial collapsed height */
            overflow: hidden;
            position: relative;
            transition: max-height 0.5s ease-out;
        }
        body.dark-theme .paper-abstract {
            color: #b0b0b0;
        }
        .paper-abstract.expanded {
            max-height: 1000px; /* Arbitrary large number for expansion */
        }
        .abstract-toggle {
            color: #3498db;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
        }
        body.dark-theme .abstract-toggle {
            color: #5dade2;
        }

        .paper-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            color: #7f8c8d;
            border-top: 1px solid #f1f2f6;
            padding-top: 15px;
        }
        body.dark-theme .paper-meta {
            color: #a0a0a0;
            border-top-color: #4a596d;
        }

        .paper-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            padding: 6px 12px;
            border: 1px solid #e9ecef;
            background: white;
            border-radius: 15px;
            text-decoration: none;
            color: #495057;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        body.dark-theme .action-btn {
            background: #3a4759;
            border-color: #4a596d;
            color: #f0f0f0;
        }

        .action-btn:hover {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }
        body.dark-theme .action-btn:hover {
            background: #5dade2;
            border-color: #5dade2;
        }

        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid #e9ecef;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        body.dark-theme .stat-card {
            background: linear-gradient(135deg, #3a4759, #2c3645);
            border-color: #4a596d;
        }


        .stat-number {
            font-size: 2em;
            font-weight: 700;
            color: #3498db;
            margin-bottom: 5px;
        }
        body.dark-theme .stat-number {
            color: #5dade2;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        body.dark-theme .stat-label {
             color: #a0a0a0;
        }

        .loading-overlay { /* Changed from .loading */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column; /* To stack text and spinner */
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            font-size: 1.2em;
        }

        .loading-spinner { /* Changed from .loading::after */
            content: '';
            display: inline-block;
            width: 50px; /* Increased size */
            height: 50px; /* Increased size */
            border: 6px solid #f3f3f3; /* Thicker border */
            border-top: 6px solid #3498db; /* Thicker border */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-top: 20px; /* Spacing from text */
        }


        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message-container {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            width: 80%;
            max-width: 600px;
        }
        .message {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 10px; /* Spacing between messages */
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            opacity: 0;
            transform: translateY(-20px);
            animation: fadeInSlideDown 0.5s forwards;
        }
        @keyframes fadeInSlideDown {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        .message.error {
            background-color: #ffebee;
            border: 1px solid #ef9a9a;
            color: #c62828;
        }
        body.dark-theme .message.error {
            background-color: #5e3232;
            border-color: #a15252;
            color: #ffcdd2;
        }

        .message.success {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
            color: #2e7d32;
        }
        body.dark-theme .message.success {
            background-color: #2c4a2d;
            border-color: #5c8c5e;
            color: #c8e6c9;
        }

        .message.info {
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            color: #1565c0;
        }
        body.dark-theme .message.info {
            background-color: #2a3f53;
            border-color: #5c7ca0;
            color: #bbdefb;
        }


        .generated-queries {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }
        body.dark-theme .generated-queries {
            background: linear-gradient(135deg, #3a4759, #2c3645);
            border-color: #4a596d;
        }

        .generated-queries h4 {
            color: #495057;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        body.dark-theme .generated-queries h4 {
            color: #c0c0c0;
        }

        .query-tag {
            display: inline-block;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            margin: 5px;
            font-size: 0.9em;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
            transition: transform 0.2s ease;
        }

        .query-tag:hover {
            transform: translateY(-2px);
        }

        .export-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }
        body.dark-theme .export-section {
             background: #3a4759;
        }

        .export-btn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 1.5em;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex; /* For centering icon */
            align-items: center; /* For centering icon */
            justify-content: center; /* For centering icon */
        }
        body.dark-theme .theme-toggle {
            background: rgba(45, 55, 71, 0.9);
            color: #f0f0f0;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        h3 { color: #2c3e50; }
        body.dark-theme h3 { color: #e0e0e0; }
        h4 { color: #495057; }
        body.dark-theme h4 { color: #c0c0c0; }


        @media (max-width: 768px) {
            .config-grid, .filter-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .author-credit {
                position: static;
                text-align: center;
                margin-top: 15px;
            }
            
            .database-selector {
                justify-content: center;
            }
            
            .results-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stats-dashboard {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Adjusted for smaller screens */
            }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle" title="Toggle Theme">🌙</button>
    
    <div class="container">
        <div class="header">
            <h1>Academic AI Paper Search</h1>
            <p>Intelligent research paper discovery across multiple databases with AI-powered query generation</p>
            <div class="author-credit">Created by Shuvam Banerji Seal</div>
        </div>

        <div id="messageContainer" class="message-container"></div>
        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
            <span id="loadingText">Processing...</span>
            <div class="loading-spinner"></div>
        </div>

        <div class="main-content">
            <!-- Configuration Section -->
            <div class="config-section">
                <h3 style="margin-bottom: 20px;">⚙️ Configuration</h3>
                <div class="config-grid">
                    <div class="form-group">
                        <label for="apiProvider">API Provider</label>
                        <select id="apiProvider">
                            <option value="openrouter">OpenRouter</option>
                            <option value="groq">Groq</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="model">Model</label>
                        <select id="model">
                            <!-- Options will be populated based on API provider -->
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="apiKey">API Key</label>
                        <input type="password" id="apiKey" placeholder="Enter your API key">
                    </div>
                    <div class="form-group">
                        <label for="maxResults">Max Results per Database</label>
                        <select id="maxResults">
                            <option value="5">5</option>
                            <option value="10">10</option>
                            <option value="20" selected>20</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                        </select>
                    </div>
                </div>
                
                <div class="toggle-container">
                    <div class="toggle-group">
                        <label for="aiSearch">AI-Powered Query Generation</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="aiSearch" checked>
                            <span class="slider"></span>
                        </div>
                    </div>
                    <div class="toggle-group">
                        <label for="autoTranslate">Auto-translate (Conceptual)</label>
                        <div class="toggle-switch">
                            <input type="checkbox" id="autoTranslate">
                            <span class="slider"></span>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <label style="margin-bottom: 10px; display: block;">🗄️ Search Databases</label>
                    <div class="database-selector">
                        <div class="database-option selected" data-db="arxiv">
                            <input type="checkbox" id="db-arxiv" value="arxiv" checked>
                            <label for="db-arxiv">ArXiv</label>
                        </div>
                        <div class="database-option selected" data-db="scholar">
                            <input type="checkbox" id="db-scholar" value="scholar" checked>
                            <label for="db-scholar">Google Scholar (Mocked)</label>
                        </div>
                        <div class="database-option" data-db="pubmed">
                            <input type="checkbox" id="db-pubmed" value="pubmed">
                            <label for="db-pubmed">PubMed</label>
                        </div>
                        <div class="database-option" data-db="semantic">
                            <input type="checkbox" id="db-semantic" value="semantic">
                            <label for="db-semantic">Semantic Scholar</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Search Section -->
            <div class="search-section">
                <h3 style="margin-bottom: 20px;">🔍 Search Papers</h3>
                
                <div class="file-upload" id="fileUploadArea">
                    <div style="font-size: 48px; margin-bottom: 15px;">📄</div>
                    <p><strong>Drop files here or click to upload</strong></p>
                    <p style="margin-top: 10px; opacity: 0.7;">Supports PDF files and images (PNG, JPG) for OCR</p>
                    <input type="file" id="fileInput" style="display: none;" accept=".pdf,.png,.jpg,.jpeg" multiple>
                </div>
                
                <div class="uploaded-files" id="uploadedFilesContainer"></div>

                <div class="form-group" style="margin-bottom: 20px;">
                    <label for="notes">📝 Additional Notes/Context for AI Query Generation</label>
                    <textarea id="notes" rows="3" placeholder="Add any additional context, research questions, or specific requirements..."></textarea>
                </div>

                <div class="advanced-filters">
                    <h4 style="margin-bottom: 15px;">🎯 Advanced Filters</h4>
                    <div class="filter-grid">
                        <div class="form-group">
                            <label for="yearRange">Publication Year</label>
                            <select id="yearRange">
                                <option value="all">All Years</option>
                                <option value="2024">2024 Only</option>
                                <option value="2023-2024">2023-2024</option>
                                <option value="2020-2024" selected>2020-2024</option>
                                <option value="2015-2024">2015-2024</option>
                                <option value="2010-2024">2010-2024</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="subject">Subject Category</label>
                            <select id="subject">
                                <option value="all">All Subjects</option>
                                <option value="math">Mathematics</option>
                                <option value="cs">Computer Science</option>
                                <option value="physics">Physics</option>
                                <option value="stat">Statistics</option>
                                <option value="econ">Economics</option>
                                <option value="q-bio">Quantitative Biology</option>
                                <option value="q-fin">Quantitative Finance</option>
                                <!-- Add more specific math categories if desired -->
                                <option value="math.AP">Math: Analysis of PDEs</option>
                                <option value="math.CO">Math: Combinatorics</option>
                                <option value="math.NT">Math: Number Theory</option>
                                <option value="math.PR">Math: Probability</option>
                                <option value="math.ST">Math: Statistics Theory</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="paperType">Paper Type (for AI Query)</label>
                            <select id="paperType">
                                <option value="all">All Types</option>
                                <option value="research">Research Articles</option>
                                <option value="review">Review Papers</option>
                                <option value="survey">Survey Papers</option>
                                <option value="conference">Conference Papers</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="search-input-container">
                    <input type="text" id="searchInput" class="search-input" placeholder="Enter your research topic, keywords, or specific questions...">
                    <button id="searchBtn" class="search-btn">🔍 Search</button>
                </div>

                <div id="generatedQueriesContainer" class="generated-queries" style="display: none;">
                    <h4>🤖 AI-Generated Search Queries:</h4>
                    <div id="queryTagsContainer"></div>
                </div>
            </div>

            <div id="statsDashboardContainer" class="stats-dashboard" style="display: none;">
                <div class="stat-card">
                    <div class="stat-number" id="totalResultsStat">0</div>
                    <div class="stat-label">Total Papers</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="avgYearStat">-</div>
                    <div class="stat-label">Avg. Year</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="databaseCountStat">0</div>
                    <div class="stat-label">Databases</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="citationCountStat">0</div>
                    <div class="stat-label">Total Citations</div>
                </div>
            </div>

            <div class="results-section">
                <div class="results-header" style="display: none;" id="resultsHeaderContainer">
                    <h3>📊 Search Results</h3>
                    <div class="sort-controls">
                        <span style="margin-right: 10px; color: #7f8c8d;">Sort by:</span>
                        <button class="sort-btn active" data-sort="relevance">Relevance</button>
                        <button class="sort-btn" data-sort="date">Date</button>
                        <button class="sort-btn" data-sort="citations">Citations</button>
                        <button class="sort-btn" data-sort="title">Title</button>
                    </div>
                </div>
                <div id="resultsContainer">
                     <p class="message info" style="text-align:center; display:block; opacity:1; transform:none;">Enter a search query to begin.</p>
                </div>
                
                <div class="export-section" id="exportSectionContainer" style="display: none;">
                    <h4 style="margin-bottom: 15px;">📥 Export Results</h4>
                    <button class="export-btn" id="exportJsonBtn">JSON</button>
                    <button class="export-btn" id="exportCsvBtn">CSV</button>
                    <button class="export-btn" id="exportBibtexBtn">BibTeX</button>
                    <button class="export-btn" id="exportPdfBtn">PDF Report</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Polyfills and Setup ---
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        } else {
            console.error("pdf.js library is not loaded!");
        }

        // --- Global Variables & Constants ---
        const API_CONFIGS = {
            openrouter: {
                baseUrl: 'https://openrouter.ai/api/v1',
                models: [
                    'anthropic/claude-3.5-sonnet', 'openai/gpt-4o', 'openai/gpt-4-turbo', 'google/gemini-flash-1.5','meta-llama/llama-3-70b-instruct',
                    'mistralai/mixtral-8x7b-instruct','anthropic/claude-3-haiku', 'google/gemini-pro', 
                ]
            },
            groq: {
                baseUrl: 'https://api.groq.com/openai/v1', // Groq uses OpenAI compatible API
                models: ['llama3-70b-8192', 'llama3-8b-8192', 'mixtral-8x7b-32768', 'gemma-7b-it']
            }
        };

        let uploadedFilesData = []; // Stores { name: string, text: string }
        let currentSearchResults = [];
        let currentSortCriteria = 'relevance';
        let tesseractWorker = null;


        // --- DOM Elements ---
        const DOMElements = {
            apiProviderSelect: document.getElementById('apiProvider'),
            modelSelect: document.getElementById('model'),
            apiKeyInput: document.getElementById('apiKey'),
            maxResultsSelect: document.getElementById('maxResults'),
            aiSearchToggle: document.getElementById('aiSearch'),
            // autoTranslateToggle: document.getElementById('autoTranslate'), // Placeholder
            databaseCheckboxes: document.querySelectorAll('.database-option input[type="checkbox"]'),
            databaseOptions: document.querySelectorAll('.database-option'),

            fileUploadArea: document.getElementById('fileUploadArea'),
            fileInput: document.getElementById('fileInput'),
            uploadedFilesContainer: document.getElementById('uploadedFilesContainer'),
            notesTextarea: document.getElementById('notes'),

            yearRangeSelect: document.getElementById('yearRange'),
            subjectSelect: document.getElementById('subject'),
            paperTypeSelect: document.getElementById('paperType'),

            searchInput: document.getElementById('searchInput'),
            searchBtn: document.getElementById('searchBtn'),
            generatedQueriesContainer: document.getElementById('generatedQueriesContainer'),
            queryTagsContainer: document.getElementById('queryTagsContainer'),

            statsDashboardContainer: document.getElementById('statsDashboardContainer'),
            totalResultsStat: document.getElementById('totalResultsStat'),
            avgYearStat: document.getElementById('avgYearStat'),
            databaseCountStat: document.getElementById('databaseCountStat'),
            citationCountStat: document.getElementById('citationCountStat'),

            resultsHeaderContainer: document.getElementById('resultsHeaderContainer'),
            resultsContainer: document.getElementById('resultsContainer'),
            sortBtns: document.querySelectorAll('.sort-btn'),

            exportSectionContainer: document.getElementById('exportSectionContainer'),
            exportJsonBtn: document.getElementById('exportJsonBtn'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            exportBibtexBtn: document.getElementById('exportBibtexBtn'),
            exportPdfBtn: document.getElementById('exportPdfBtn'),

            themeToggleBtn: document.getElementById('themeToggle'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            messageContainer: document.getElementById('messageContainer'),
        };

        // --- Utility Functions ---
        function showMessage(type, message, duration = 5000) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            DOMElements.messageContainer.appendChild(messageDiv);
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = 'translateY(-20px) translateX(-50%)'; // Slide up
                setTimeout(() => messageDiv.remove(), 500);
            }, duration);
        }

        function setLoading(isLoading, text = "Processing...") {
            DOMElements.loadingOverlay.style.display = isLoading ? 'flex' : 'none';
            DOMElements.loadingText.textContent = text;
            DOMElements.searchBtn.disabled = isLoading;
        }

        async function initializeTesseractWorker() {
            if (!tesseractWorker && typeof Tesseract !== 'undefined') {
                setLoading(true, "Initializing OCR Engine...");
                try {
                    tesseractWorker = await Tesseract.createWorker('eng', 1, {
                        logger: m => console.log(m) // Optional: for progress logging
                    });
                    showMessage('info', 'OCR engine initialized.', 2000);
                } catch (error) {
                    console.error("Error initializing Tesseract worker:", error);
                    showMessage('error', 'Failed to initialize OCR engine.');
                    tesseractWorker = null; // Ensure it's null if failed
                } finally {
                    setLoading(false);
                }
            } else if (typeof Tesseract === 'undefined') {
                 console.error("Tesseract.js library is not loaded!");
                 showMessage('error', 'OCR library (Tesseract.js) not found.');
            }
        }


        // --- Initialization and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            updateModelDropdown();
            initializeTesseractWorker(); // Initialize Tesseract on load

            DOMElements.apiProviderSelect.addEventListener('change', updateModelDropdown);
            DOMElements.searchBtn.addEventListener('click', handleSearch);
            
            DOMElements.fileUploadArea.addEventListener('click', () => DOMElements.fileInput.click());
            DOMElements.fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                DOMElements.fileUploadArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser opening file
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                DOMElements.fileUploadArea.addEventListener(eventName, () => DOMElements.fileUploadArea.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                DOMElements.fileUploadArea.addEventListener(eventName, () => DOMElements.fileUploadArea.classList.remove('dragover'), false);
            });
            DOMElements.fileUploadArea.addEventListener('drop', handleDrop, false);

            DOMElements.sortBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    DOMElements.sortBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSortCriteria = btn.dataset.sort;
                    sortAndRenderResults();
                });
            });

            DOMElements.exportJsonBtn.addEventListener('click', () => exportResults('json'));
            DOMElements.exportCsvBtn.addEventListener('click', () => exportResults('csv'));
            DOMElements.exportBibtexBtn.addEventListener('click', () => exportResults('bibtex'));
            DOMElements.exportPdfBtn.addEventListener('click', () => exportResults('pdf'));

            DOMElements.themeToggleBtn.addEventListener('click', toggleTheme);
            if (localStorage.getItem('theme') === 'dark-theme') {
                document.body.classList.add('dark-theme');
                DOMElements.themeToggleBtn.textContent = '☀️';
            }

            DOMElements.databaseOptions.forEach(option => {
                const checkbox = option.querySelector('input[type="checkbox"]');
                option.addEventListener('click', (e) => {
                    if (e.target !== checkbox) { // Prevent double toggle if label is clicked
                        checkbox.checked = !checkbox.checked;
                    }
                    option.classList.toggle('selected', checkbox.checked);
                });
            });
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            let dt = e.dataTransfer;
            let files = dt.files;
            handleFiles(files);
        }

        function updateModelDropdown() {
            const provider = DOMElements.apiProviderSelect.value;
            const models = API_CONFIGS[provider].models;
            DOMElements.modelSelect.innerHTML = models.map(model => `<option value="${model}">${model}</option>`).join('');
        }

        // --- File Handling and OCR ---
        async function handleFiles(files) {
            if (!files.length) return;
            setLoading(true, "Processing files...");

            for (const file of files) {
                if (uploadedFilesData.find(f => f.name === file.name)) {
                    showMessage('info', `File ${file.name} already uploaded.`);
                    continue;
                }
                let text = '';
                try {
                    if (file.type === "application/pdf") {
                        text = await extractTextFromPdf(file);
                    } else if (file.type.startsWith("image/")) {
                        if (!tesseractWorker) {
                           await initializeTesseractWorker(); // try to init again if not ready
                           if (!tesseractWorker) { // if still not ready, skip OCR
                                showMessage('error', 'OCR Engine not ready. Cannot process image.');
                                continue;
                           }
                        }
                        text = await extractTextFromImage(file);
                    } else {
                        showMessage('error', `Unsupported file type: ${file.name}`);
                        continue;
                    }
                    uploadedFilesData.push({ name: file.name, text: text });
                    renderUploadedFiles();
                    showMessage('success', `Processed: ${file.name}`);
                } catch (error) {
                    console.error("Error processing file:", file.name, error);
                    showMessage('error', `Error processing ${file.name}: ${error.message}`);
                }
            }
            setLoading(false);
        }

        async function extractTextFromPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(item => item.str).join(' ') + '\n';
            }
            return fullText;
        }

        async function extractTextFromImage(file) {
            if (!tesseractWorker) {
                throw new Error("Tesseract worker not initialized.");
            }
            const { data: { text } } = await tesseractWorker.recognize(file);
            return text;
        }

        function renderUploadedFiles() {
            DOMElements.uploadedFilesContainer.innerHTML = uploadedFilesData.map((file, index) => `
                <div class="file-tag">
                    ${file.name}
                    <span class="remove" data-index="${index}" title="Remove file">×</span>
                </div>
            `).join('');

            DOMElements.uploadedFilesContainer.querySelectorAll('.remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    uploadedFilesData.splice(index, 1);
                    renderUploadedFiles();
                });
            });
        }

        // --- LLM Query Generation ---
        async function generateLLMQueries(mainTopic, notes, fileTextContent) {
            const provider = DOMElements.apiProviderSelect.value;
            const model = DOMElements.modelSelect.value;
            const apiKey = DOMElements.apiKeyInput.value;

            if (!apiKey) {
                showMessage('error', 'API Key is required for AI-powered query generation.');
                return [];
            }

            let context = `Main topic: ${mainTopic}\n`;
            if (notes) context += `Additional notes/context: ${notes}\n`;
            if (fileTextContent) context += `Content from uploaded files:\n${fileTextContent.substring(0, 4000)}\n`; // Limit context length

            const subject = DOMElements.subjectSelect.value;
            const paperType = DOMElements.paperTypeSelect.value;
            
            let subjectHint = "";
            if (subject !== 'all') {
                subjectHint = `The user is particularly interested in ${subject}. `;
                if (subject.startsWith('math')) {
                    subjectHint += `For ArXiv, queries like "cat:${subject} AND (keyword1 OR keyword2)" or using specific subcategories like "math.NT" for Number Theory are useful. `;
                }
            }
            let paperTypeHint = "";
            if (paperType !== 'all') {
                paperTypeHint = `Focus on finding ${paperType}. `
            }

            const prompt = `
                You are an expert research assistant helping a user find academic papers.
                Based on the following information, generate 3-5 diverse and effective search queries suitable for academic search engines like ArXiv, Google Scholar, PubMed, and Semantic Scholar.
                ${subjectHint}
                ${paperTypeHint}
                Prioritize queries that would yield papers in mathematics if the context suggests it.
                For ArXiv, you can use field codes (e.g., ti: for title, au: for author, cat: for category).
                For general search engines, use boolean operators (AND, OR, NOT) and phrase searching ("").
                Return ONLY a JSON array of strings, where each string is a search query. Example: ["query1", "query2", "query3"]

                User-provided context:
                ${context}
            `;

            setLoading(true, "Generating AI queries...");
            try {
                const response = await fetch(`${API_CONFIGS[provider].baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.5, // Lower temperature for more focused queries
                        max_tokens: 300
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`LLM API Error (${response.status}): ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const content = data.choices[0]?.message?.content;
                if (content) {
                    // Try to parse as JSON array of strings
                    try {
                        let queries = JSON.parse(content);
                        if (Array.isArray(queries) && queries.every(q => typeof q === 'string')) {
                             showMessage('success', 'AI queries generated.');
                            return queries;
                        }
                    } catch (e) { /* ignore parsing error, try regex */ }

                    // Fallback: extract queries if not perfect JSON array (e.g. if LLM adds surrounding text)
                    const queryRegex = /"([^"]+)"/g;
                    let matches;
                    const extractedQueries = [];
                    while ((matches = queryRegex.exec(content)) !== null) {
                        extractedQueries.push(matches[1]);
                    }
                    if (extractedQueries.length > 0) {
                        showMessage('success', 'AI queries generated (extracted).');
                        return extractedQueries;
                    }
                }
                throw new Error("LLM did not return valid queries.");

            } catch (error) {
                console.error("Error generating LLM queries:", error);
                showMessage('error', `Failed to generate AI queries: ${error.message}`);
                return [];
            } finally {
                setLoading(false);
            }
        }


        // --- Search Logic ---
        async function handleSearch() {
            const mainTopic = DOMElements.searchInput.value.trim();
            if (!mainTopic && !uploadedFilesData.length) {
                showMessage('error', 'Please enter a search topic or upload a file.');
                return;
            }

            currentSearchResults = [];
            DOMElements.resultsContainer.innerHTML = ''; // Clear previous results
            setLoading(true, "Searching...");

            const selectedDBs = Array.from(DOMElements.databaseCheckboxes)
                                   .filter(cb => cb.checked)
                                   .map(cb => cb.value);

            if (selectedDBs.length === 0) {
                showMessage('error', 'Please select at least one database to search.');
                setLoading(false);
                return;
            }

            let searchQueries = [mainTopic]; // Default to user's input

            if (DOMElements.aiSearchToggle.checked) {
                const notes = DOMElements.notesTextarea.value.trim();
                const fileTextContent = uploadedFilesData.map(f => f.text).join('\n\n').trim();
                const generatedQueries = await generateLLMQueries(mainTopic, notes, fileTextContent);
                
                if (generatedQueries.length > 0) {
                    searchQueries = generatedQueries; // Use AI queries if available
                    DOMElements.generatedQueriesContainer.style.display = 'block';
                    DOMElements.queryTagsContainer.innerHTML = generatedQueries.map(q => `<span class="query-tag">${q}</span>`).join('');
                } else {
                    DOMElements.generatedQueriesContainer.style.display = 'none';
                    if (!mainTopic) { // If main topic was empty and AI failed
                        showMessage('error', 'AI query generation failed and no manual topic entered.');
                        setLoading(false);
                        return;
                    }
                }
            } else {
                DOMElements.generatedQueriesContainer.style.display = 'none';
                 if (!mainTopic) { // If main topic was empty and AI search off
                    showMessage('error', 'AI search is off and no manual topic entered.');
                    setLoading(false);
                    return;
                }
            }


            const maxResults = parseInt(DOMElements.maxResultsSelect.value);
            const filters = getAdvancedFilters();
            let allFetches = [];

            for (const db of selectedDBs) {
                // For simplicity, we'll use the first AI query for each DB or the main topic.
                // A more advanced approach might use different queries or combine results.
                const queryToUse = searchQueries[0] || mainTopic; 
                
                // Or, iterate through all AI queries for each DB (can be many requests)
                // For now, let's use the first relevant query, or all if not too many
                let queriesForDb = searchQueries.slice(0, Math.min(searchQueries.length, 3)); // Use up to 3 AI queries or the single manual one
                if (queriesForDb.length === 0 && mainTopic) queriesForDb.push(mainTopic);


                queriesForDb.forEach(q => {
                    if (!q) return; // Skip empty queries
                    switch (db) {
                        case 'arxiv':
                            allFetches.push(searchArxiv(q, maxResults, filters).catch(handleSearchError(db)));
                            break;
                        case 'scholar':
                            allFetches.push(searchGoogleScholarMock(q, maxResults, filters).catch(handleSearchError(db)));
                            break;
                        case 'pubmed':
                            allFetches.push(searchPubMed(q, maxResults, filters).catch(handleSearchError(db)));
                            break;
                        case 'semantic':
                            allFetches.push(searchSemanticScholar(q, maxResults, filters).catch(handleSearchError(db)));
                            break;
                    }
                });
            }

            const resultsFromAllDBs = await Promise.all(allFetches);
            resultsFromAllDBs.forEach(resultSet => {
                if (resultSet && Array.isArray(resultSet)) { // Filter out nulls from errors
                    currentSearchResults.push(...resultSet);
                }
            });
            
            // Deduplicate results based on title and first author (simple deduplication)
            const uniqueResults = [];
            const seen = new Set();
            for (const paper of currentSearchResults) {
                const key = `${paper.title.toLowerCase()}|${(paper.authors && paper.authors.length > 0) ? paper.authors[0].toLowerCase() : ''}`;
                if (!seen.has(key)) {
                    uniqueResults.push(paper);
                    seen.add(key);
                }
            }
            currentSearchResults = uniqueResults;


            if (currentSearchResults.length === 0) {
                 DOMElements.resultsContainer.innerHTML = `<p class="message info" style="text-align:center; display:block; opacity:1; transform:none;">No papers found matching your criteria.</p>`;
            } else {
                sortAndRenderResults();
                DOMElements.resultsHeaderContainer.style.display = 'flex';
                DOMElements.exportSectionContainer.style.display = 'block';
            }
            updateStatsDashboard(currentSearchResults, selectedDBs.length);
            setLoading(false);
        }
        
        function handleSearchError(dbName) {
            return (error) => {
                console.error(`Error searching ${dbName}:`, error);
                showMessage('error', `Failed to fetch results from ${dbName}: ${error.message}`);
                return null; // Return null so Promise.all doesn't reject entirely
            };
        }

        function getAdvancedFilters() {
            const yearRange = DOMElements.yearRangeSelect.value;
            let yearStart, yearEnd;
            if (yearRange.includes('-')) {
                [yearStart, yearEnd] = yearRange.split('-').map(Number);
            } else if (yearRange !== 'all') {
                yearStart = yearEnd = Number(yearRange);
            }

            return {
                yearStart,
                yearEnd,
                subject: DOMElements.subjectSelect.value,
                paperType: DOMElements.paperTypeSelect.value // Mainly for LLM, but can be used for filtering if API supports
            };
        }

        // --- Database Specific Search Functions ---
        async function searchArxiv(query, maxResults, filters) {
            let searchQuery = query;
            if (filters.subject && filters.subject !== 'all' && filters.subject.startsWith('math')) {
                 // More specific ArXiv search for math by category
                 searchQuery = `(${query}) AND (cat:${filters.subject}*)`;
            } else if (filters.subject && filters.subject !== 'all') {
                searchQuery = `(${query}) AND (cat:${filters.subject}*)`; // General subject category
            }
            // ArXiv API expects '+' for spaces in query terms, but often works with URL encoding too.
            // Using `all:` prefix for general keyword search, or structure as needed.
            // A common structure: `all:(term1 term2) AND ti:(title_term) AND au:(author_term)`
            // For simplicity, we'll use a general search.
            const baseUrl = 'https://export.arxiv.org/api/query';
            const params = new URLSearchParams({
                search_query: `all:${searchQuery}`,
                max_results: maxResults,
                sortBy: 'relevance', // or 'lastUpdatedDate', 'submittedDate'
                sortOrder: 'descending'
            });
            const response = await fetch(`${baseUrl}?${params.toString()}`);
            if (!response.ok) throw new Error(`ArXiv API error: ${response.statusText}`);
            
            const xmlText = await response.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            const entries = xmlDoc.getElementsByTagName("entry");
            const papers = [];

            for (let entry of entries) {
                const title = entry.getElementsByTagName("title")[0]?.textContent.trim().replace(/\s+/g, ' ') || 'N/A';
                const authors = Array.from(entry.getElementsByTagName("author")).map(a => a.getElementsByTagName("name")[0]?.textContent.trim());
                const abstract = entry.getElementsByTagName("summary")[0]?.textContent.trim().replace(/\s+/g, ' ') || 'N/A';
                const published = entry.getElementsByTagName("published")[0]?.textContent || '';
                const updated = entry.getElementsByTagName("updated")[0]?.textContent || '';
                const id = entry.getElementsByTagName("id")[0]?.textContent || '';
                const pdfLink = Array.from(entry.getElementsByTagName("link")).find(l => l.getAttribute('title') === 'pdf')?.getAttribute('href') || id.replace('/abs/', '/pdf/');
                const primaryCategory = entry.getElementsByTagName("arxiv:primary_category")[0]?.getAttribute('term') || '';


                let year = new Date(published || updated).getFullYear();
                if (filters.yearStart && year < filters.yearStart) continue;
                if (filters.yearEnd && year > filters.yearEnd) continue;


                papers.push({
                    id: id,
                    title,
                    authors,
                    abstract,
                    publishedDate: published || updated,
                    year: year,
                    url: id,
                    pdfUrl: pdfLink,
                    source: 'ArXiv',
                    relevanceScore: 1, // ArXiv API sort by relevance is implicit
                    citations: null, // ArXiv doesn't directly provide citation counts in basic API
                    categories: [primaryCategory]
                });
            }
            return papers;
        }

        async function searchGoogleScholarMock(query, maxResults, filters) {
            // !!! This is a MOCKED function. Google Scholar has no free public API. !!!
            // !!! For real results, use a paid service like SerpApi.          !!!
            showMessage('info', "Google Scholar search is MOCKED. Displaying sample data.", 7000);
            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay
            const papers = [];
            for (let i = 0; i < Math.min(maxResults, 5); i++) {
                const year = filters.yearStart ? filters.yearStart + i % ( (filters.yearEnd || filters.yearStart) - filters.yearStart + 1) : 2020 + i;
                if (filters.yearStart && year < filters.yearStart) continue;
                if (filters.yearEnd && year > filters.yearEnd) continue;

                papers.push({
                    id: `scholar-mock-${i}-${Date.now()}`,
                    title: `Mock Scholar Paper on "${query.substring(0,20)}..." (${i + 1})`,
                    authors: [`Mock Author ${String.fromCharCode(65 + i)}`, "et al."],
                    abstract: `This is a mock abstract for a paper found on Google Scholar related to "${query}". It discusses various important concepts and methodologies. (Mocked result).`,
                    publishedDate: `${year}-01-01`,
                    year: year,
                    url: `https://scholar.google.com/scholar?q=${encodeURIComponent(query)}`,
                    pdfUrl: null, // Scholar often links to publisher sites, not direct PDFs
                    source: 'Google Scholar (Mock)',
                    relevanceScore: 0.9 - i * 0.05,
                    citations: Math.floor(Math.random() * 200)
                });
            }
            return papers;
        }

        async function searchPubMed(query, maxResults, filters) {
            const eutilsBase = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/';
            
            // Step 1: Search for IDs
            let term = query;
            if (filters.yearStart || filters.yearEnd) {
                const start = filters.yearStart || '1900';
                const end = filters.yearEnd || new Date().getFullYear();
                term += ` AND ("${start/101/01}"[Date - Publication] : "${end}/12/31"[Date - Publication])`;
            }

            const searchParams = new URLSearchParams({
                db: 'pubmed',
                term: term,
                retmax: maxResults,
                usehistory: 'y',
                retmode: 'json'
            });
            const searchResp = await fetch(`${eutilsBase}esearch.fcgi?${searchParams.toString()}`);
            if (!searchResp.ok) throw new Error(`PubMed ESearch API error: ${searchResp.statusText}`);
            const searchData = await searchResp.json();

            const idList = searchData.esearchresult?.idlist;
            if (!idList || idList.length === 0) return [];

            // Step 2: Fetch summaries for IDs
            const summaryParams = new URLSearchParams({
                db: 'pubmed',
                id: idList.join(','),
                retmode: 'xml' // XML is richer for abstracts on PubMed summary
            });
            // Fetching summaries, sometimes better to use efetch for full abstract, but esummary is quicker
            const summaryResp = await fetch(`${eutilsBase}esummary.fcgi?${summaryParams.toString()}`);
            if (!summaryResp.ok) throw new Error(`PubMed ESummary API error: ${summaryResp.statusText}`);
            
            const xmlText = await summaryResp.text();
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, "text/xml");
            const docSums = xmlDoc.getElementsByTagName("DocSum");
            const papers = [];

            for (let doc of docSums) {
                const id = doc.getElementsByTagName("Id")[0]?.textContent;
                const title = doc.querySelector('Item[Name="Title"]')?.textContent || 'N/A';
                const authors = Array.from(doc.querySelectorAll('Item[Name="AuthorList"] Item[Name="Author"]'))
                                     .map(a => a.textContent);
                // PubMed's esummary doesn't directly provide abstracts.
                // For full abstracts, efetch is needed, or parse from article link.
                // Here, we'll try to find an abstract snippet if available or leave it N/A.
                // A more robust solution would be another call to efetch for each ID.
                let abstract = "Abstract not available via ESummary. Full text link may contain it.";
                // Try to find if 'AbstractText' is available (rare in esummary for pubmed)
                const abstractNode = Array.from(doc.getElementsByTagName("Item")).find(item => item.getAttribute("Name") === "Abstract");
                if (abstractNode) abstract = abstractNode.textContent;


                const pubDateStr = doc.querySelector('Item[Name="PubDate"]')?.textContent || '';
                const year = parseInt(pubDateStr.substring(0, 4)) || null;

                const doi = Array.from(doc.getElementsByTagName("Item")).find(item => item.getAttribute("Name") === "DOI")?.textContent || null;
                const url = doi ? `https://doi.org/${doi}` : `https://pubmed.ncbi.nlm.nih.gov/${id}/`;

                papers.push({
                    id: `pubmed-${id}`,
                    title,
                    authors,
                    abstract,
                    publishedDate: pubDateStr,
                    year,
                    url,
                    pdfUrl: null, // PubMed links to articles, PDFs are on publisher sites
                    source: 'PubMed',
                    relevanceScore: 0.8, // Default relevance
                    citations: null // PubMed API doesn't easily provide citation counts like this
                });
            }
            return papers;
        }

        async function searchSemanticScholar(query, maxResults, filters) {
            // Semantic Scholar API key can be requested for higher rate limits, but basic usage is often keyless.
            // Using the new Graph API endpoint:
            const baseUrl = 'https://api.semanticscholar.org/graph/v1/paper/search';
            const params = new URLSearchParams({
                query: query,
                limit: maxResults,
                fields: 'title,authors.name,abstract,year,url,venue,publicationDate,externalIds,citationCount,tldr'
            });

            if (filters.yearStart || filters.yearEnd) {
                const start = filters.yearStart || '*';
                const end = filters.yearEnd || '*';
                params.append('year', `${start}-${end}`);
            }

            const response = await fetch(`${baseUrl}?${params.toString()}`);
            if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(`Semantic Scholar API error (${response.status}): ${errorData.message || response.statusText}`);
            }
            const data = await response.json();
            const papers = [];

            if (data.data) {
                for (let item of data.data) {
                    // TLDR can be a good substitute if abstract is too long or missing
                    let abstractText = item.abstract;
                    if (!abstractText && item.tldr && item.tldr.text) {
                        abstractText = `TLDR: ${item.tldr.text}`;
                    }
                    if (!abstractText) abstractText = "No abstract available.";


                    papers.push({
                        id: `semantic-${item.paperId}`,
                        title: item.title || 'N/A',
                        authors: item.authors?.map(a => a.name) || [],
                        abstract: abstractText,
                        publishedDate: item.publicationDate || (item.year ? `${item.year}-01-01` : 'N/A'),
                        year: item.year || null,
                        url: item.url,
                        pdfUrl: item.externalIds?.DOI ? `https://doi.org/${item.externalIds.DOI}` : null, // Or try to find PDF link
                        source: 'Semantic Scholar',
                        relevanceScore: item.score || 0.7, // If API provides score
                        citations: item.citationCount || 0,
                        venue: item.venue
                    });
                }
            }
            return papers;
        }

        // --- Results Rendering and Sorting ---
        function sortAndRenderResults() {
            if (!currentSearchResults || currentSearchResults.length === 0) return;

            currentSearchResults.sort((a, b) => {
                switch (currentSortCriteria) {
                    case 'date':
                        return (new Date(b.publishedDate || 0)) - (new Date(a.publishedDate || 0));
                    case 'citations':
                        return (b.citations || 0) - (a.citations || 0);
                    case 'title':
                        return a.title.localeCompare(b.title);
                    case 'relevance':
                    default:
                        return (b.relevanceScore || 0) - (a.relevanceScore || 0);
                }
            });
            renderResults(currentSearchResults);
        }

        function renderResults(results) {
            if (!results || results.length === 0) {
                 DOMElements.resultsContainer.innerHTML = `<p class="message info" style="text-align:center; display:block; opacity:1; transform:none;">No papers found matching your criteria.</p>`;
                 DOMElements.resultsHeaderContainer.style.display = 'none';
                 DOMElements.exportSectionContainer.style.display = 'none';
                 return;
            }
            DOMElements.resultsContainer.innerHTML = results.map(paper => `
                <div class="paper-card">
                    <div class="paper-header">
                        <h4 class="paper-title"><a href="${paper.url}" target="_blank" rel="noopener noreferrer">${paper.title}</a></h4>
                        <span class="paper-source">${paper.source}</span>
                    </div>
                    <p class="paper-authors">Authors: ${paper.authors?.join(', ') || 'N/A'}</p>
                    <div class="paper-abstract">
                        ${paper.abstract ? paper.abstract.substring(0, 300) + (paper.abstract.length > 300 ? '...' : '') : 'No abstract available.'}
                    </div>
                    ${paper.abstract && paper.abstract.length > 300 ? '<span class="abstract-toggle">Read more</span>' : ''}
                    <div class="paper-meta">
                        <span>Published: ${paper.publishedDate ? new Date(paper.publishedDate).toLocaleDateString() : 'N/A'}</span>
                        <span>Citations: ${paper.citations !== null ? paper.citations : 'N/A'}</span>
                        <div class="paper-actions">
                            ${paper.pdfUrl ? `<a href="${paper.pdfUrl}" class="action-btn" target="_blank" rel="noopener noreferrer">PDF</a>` : ''}
                            <a href="${paper.url}" class="action-btn" target="_blank" rel="noopener noreferrer">Source Page</a>
                        </div>
                    </div>
                </div>
            `).join('');
            
            // Add event listeners for "Read more" toggles
            DOMElements.resultsContainer.querySelectorAll('.abstract-toggle').forEach((toggle, index) => {
                toggle.addEventListener('click', () => {
                    const abstractDiv = toggle.previousElementSibling; // The .paper-abstract div
                    abstractDiv.classList.toggle('expanded');
                    if (abstractDiv.classList.contains('expanded')) {
                        abstractDiv.textContent = results[index].abstract; // Show full abstract
                        toggle.textContent = 'Read less';
                    } else {
                        abstractDiv.textContent = results[index].abstract.substring(0, 300) + '...';
                        toggle.textContent = 'Read more';
                    }
                });
            });
        }

        // --- Stats Dashboard ---
        function updateStatsDashboard(results, dbCount) {
            if (!results || results.length === 0) {
                DOMElements.statsDashboardContainer.style.display = 'none';
                return;
            }
            DOMElements.statsDashboardContainer.style.display = 'grid';
            DOMElements.totalResultsStat.textContent = results.length;
            DOMElements.databaseCountStat.textContent = dbCount;

            const years = results.map(p => p.year).filter(y => y && !isNaN(y));
            if (years.length > 0) {
                const avgYear = years.reduce((sum, year) => sum + year, 0) / years.length;
                DOMElements.avgYearStat.textContent = Math.round(avgYear);
            } else {
                DOMElements.avgYearStat.textContent = '-';
            }

            const totalCitations = results.reduce((sum, p) => sum + (p.citations || 0), 0);
            DOMElements.citationCountStat.textContent = totalCitations;
        }

        // --- Export Functionality ---
        function exportResults(format) {
            if (currentSearchResults.length === 0) {
                showMessage('info', 'No results to export.');
                return;
            }

            const filename = `academic_search_results_${new Date().toISOString().slice(0,10)}`;

            switch (format) {
                case 'json':
                    const jsonData = JSON.stringify(currentSearchResults, null, 2);
                    downloadFile(jsonData, `${filename}.json`, 'application/json');
                    break;
                case 'csv':
                    if (typeof Papa === 'undefined') {
                        showMessage('error', 'CSV Export library (PapaParse) not loaded.'); return;
                    }
                    const csvData = Papa.unparse(currentSearchResults.map(p => ({
                        Title: p.title,
                        Authors: p.authors?.join('; ') || '',
                        Year: p.year || '',
                        Source: p.source,
                        URL: p.url,
                        PDF_URL: p.pdfUrl || '',
                        Abstract: p.abstract?.replace(/(\r\n|\n|\r)/gm, " ") || '', // Remove newlines for CSV
                        Citations: p.citations !== null ? p.citations : '',
                        PublishedDate: p.publishedDate || ''
                    })));
                    downloadFile(csvData, `${filename}.csv`, 'text/csv;charset=utf-8;');
                    break;
                case 'bibtex':
                    const bibtexData = currentSearchResults.map(p => {
                        const authorList = p.authors?.join(' and ') || 'Unknown Author';
                        const entryType = (p.source === "ArXiv" || (p.venue && p.venue.toLowerCase().includes('arxiv'))) ? 'article' : 'misc'; // Simple guess
                        // BibTeX keys need to be unique and simple: AuthorYearTitleWord
                        const firstAuthorLastName = p.authors?.[0]?.split(' ').pop() || 'Unknown';
                        const titleFirstWord = p.title?.split(' ')[0]?.replace(/[^a-zA-Z0-9]/g, '') || 'N_A';
                        const bibKey = `${firstAuthorLastName}${p.year || 'ND'}${titleFirstWord}`;

                        return `@${entryType}{${bibKey},
  author    = {${authorList}},
  title     = {${p.title}},
  year      = {${p.year || 'n.d.'}},
  ${p.url ? `url       = {${p.url}},` : ''}
  ${p.source === 'ArXiv' && p.id ? `eprint    = {${p.id.replace('http://arxiv.org/abs/','')}},
  archivePrefix = {arXiv},
  primaryClass  = {${p.categories?.[0] || ''}},` : ''}
  ${p.source === 'PubMed' && p.id.startsWith('pubmed-') ? `PMID      = {${p.id.replace('pubmed-','')}},` : ''}
  ${p.citations !== null ? `note      = {Citations: ${p.citations}},` : ''}
  source    = {${p.source}}
}`;
                    }).join('\n\n');
                    downloadFile(bibtexData, `${filename}.bib`, 'application/x-bibtex');
                    break;
                case 'pdf':
                    if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                         showMessage('error', 'PDF Export library (jsPDF) not loaded.'); return;
                    }
                    const { jsPDF } = jspdf;
                    const doc = new jsPDF();
                    doc.setFontSize(18);
                    doc.text("Academic Search Results", 14, 22);
                    doc.setFontSize(11);
                    doc.setTextColor(100);
                    doc.text(`Exported on: ${new Date().toLocaleDateString()}`, 14, 30);
                    
                    let yPos = 40;
                    currentSearchResults.forEach((p, index) => {
                        if (yPos > 270) { // New page if yPos exceeds ~270mm
                            doc.addPage();
                            yPos = 20;
                        }
                        doc.setFontSize(12);
                        doc.setTextColor(0,0,255); // Blue for title/link
                        doc.textWithLink(`${index + 1}. ${p.title}`, 14, yPos, { url: p.url });
                        doc.setTextColor(0); // Reset color
                        yPos += 7;
                        doc.setFontSize(9);
                        doc.text(`Authors: ${p.authors?.join(', ') || 'N/A'}`, 16, yPos);
                        yPos += 5;
                        doc.text(`Source: ${p.source} | Year: ${p.year || 'N/A'} | Citations: ${p.citations !== null ? p.citations : 'N/A'}`, 16, yPos);
                        yPos += 7;
                    });
                    doc.save(`${filename}.pdf`);
                    break;
            }
            showMessage('success', `${format.toUpperCase()} export started.`);
        }

        function downloadFile(content, filename, contentType) {
            const a = document.createElement('a');
            const blob = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // --- Theme Toggle ---
        function toggleTheme() {
            document.body.classList.toggle('dark-theme');
            if (document.body.classList.contains('dark-theme')) {
                DOMElements.themeToggleBtn.textContent = '☀️'; // Sun icon for dark mode
                localStorage.setItem('theme', 'dark-theme');
            } else {
                DOMElements.themeToggleBtn.textContent = '🌙'; // Moon icon for light mode
                localStorage.setItem('theme', 'light-theme');
            }
        }

    </script>
</body>
</html>